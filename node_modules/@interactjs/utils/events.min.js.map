{
	"version": 3,
	"sources": [
		"events.ts"
	],
	"names": [
		"contains",
		"domUtils",
		"is",
		"pExtend",
		"pointerUtils",
		"elements",
		"targets",
		"delegatedEvents",
		"documents",
		"add",
		"element",
		"type",
		"listener",
		"optionalArg",
		"options",
		"getOptions",
		"elementIndex",
		"indexOf",
		"target",
		"events",
		"typeCount",
		"push",
		"removeEventListener",
		"addEventListener",
		"supportsOptions",
		"capture",
		"remove",
		"len",
		"length",
		"i",
		"splice",
		"hasOwnProperty",
		"delegateListener",
		"event",
		"fakeEvent",
		"FakeEvent",
		"delegated",
		"eventTarget",
		"getEventTargets",
		"selectors",
		"selector",
		"context",
		"contexts",
		"matchesSelector",
		"nodeContains",
		"listeners",
		"currentTarget",
		"fn",
		"passive",
		"parentNode",
		"delegateUseCapture",
		"param",
		"object",
		"constructor",
		"originalEvent",
		"this",
		"preventOriginalDefault",
		"preventDefault",
		"stopPropagation",
		"stopImmediatePropagation",
		"addDelegate",
		"doc",
		"index",
		"removeDelegate",
		"matchFound",
		"supportsPassive",
		"_elements",
		"_targets",
		"init",
		"window",
		"document",
		"createElement"
	],
	"mappings": "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",
	"sourcesContent": [
		"import { contains } from './arr'\nimport * as domUtils from './domUtils'\nimport * as is from './is'\nimport pExtend from './pointerExtend'\nimport * as pointerUtils from './pointerUtils'\n\ntype Listener = (event: Event | FakeEvent) => any\n\nconst elements: EventTarget[] = []\nconst targets: Array<{\n  events: { [type: string]: Listener[] }\n  typeCount: number\n}> = []\n\nconst delegatedEvents: {\n  [type: string]: {\n    selectors: string[]\n    contexts: Node[]\n    listeners: Array<Array<[Listener, boolean, boolean]>>\n  }\n} = {}\nconst documents: Document[] = []\n\nfunction add (element: EventTarget, type: string, listener: Listener, optionalArg?: boolean | any) {\n  const options = getOptions(optionalArg)\n  let elementIndex = elements.indexOf(element)\n  let target = targets[elementIndex]\n\n  if (!target) {\n    target = {\n      events: {},\n      typeCount: 0,\n    }\n\n    elementIndex = elements.push(element) - 1\n    targets.push(target)\n  }\n\n  if (!target.events[type]) {\n    target.events[type] = []\n    target.typeCount++\n  }\n\n  if (element.removeEventListener && !contains(target.events[type], listener)) {\n    element.addEventListener(type, listener as any, events.supportsOptions ? options : !!options.capture)\n    target.events[type].push(listener)\n  }\n}\n\nfunction remove (element: EventTarget, type: string, listener?: 'all' | Listener, optionalArg?: boolean | any) {\n  const options = getOptions(optionalArg)\n  const elementIndex = elements.indexOf(element)\n  const target = targets[elementIndex]\n\n  if (!target || !target.events) {\n    return\n  }\n\n  if (type === 'all') {\n    for (type in target.events) {\n      if (target.events.hasOwnProperty(type)) {\n        remove(element, type, 'all')\n      }\n    }\n    return\n  }\n\n  if (target.events[type]) {\n    const len = target.events[type].length\n\n    if (listener === 'all') {\n      for (let i = 0; i < len; i++) {\n        remove(element, type, target.events[type][i], options)\n      }\n      return\n    }\n    else {\n      for (let i = 0; i < len; i++) {\n        if (element.removeEventListener && target.events[type][i] === listener) {\n          element.removeEventListener(type, listener as any, events.supportsOptions ? options : !!options.capture)\n          target.events[type].splice(i, 1)\n\n          break\n        }\n      }\n    }\n\n    if (target.events[type] && target.events[type].length === 0) {\n      (target.events[type] as any) = null\n      target.typeCount--\n    }\n  }\n\n  if (!target.typeCount) {\n    targets.splice(elementIndex, 1)\n    elements.splice(elementIndex, 1)\n  }\n}\n\nfunction addDelegate (selector: string, context: Node, type: string, listener: Listener, optionalArg?: any) {\n  const options = getOptions(optionalArg)\n  if (!delegatedEvents[type]) {\n    delegatedEvents[type] = {\n      contexts : [],\n      listeners: [],\n      selectors: [],\n    }\n\n    // add delegate listener functions\n    for (const doc of documents) {\n      add(doc, type, delegateListener)\n      add(doc, type, delegateUseCapture, true)\n    }\n  }\n\n  const delegated = delegatedEvents[type]\n  let index\n\n  for (index = delegated.selectors.length - 1; index >= 0; index--) {\n    if (delegated.selectors[index] === selector &&\n        delegated.contexts[index] === context) {\n      break\n    }\n  }\n\n  if (index === -1) {\n    index = delegated.selectors.length\n\n    delegated.selectors.push(selector)\n    delegated.contexts.push(context)\n    delegated.listeners.push([])\n  }\n\n  // keep listener and capture and passive flags\n  delegated.listeners[index].push([listener, !!options.capture, options.passive])\n}\n\nfunction removeDelegate (\n  selector: string,\n  context: Document | Interact.Element,\n  type: string,\n  listener?: Listener,\n  optionalArg?: any,\n) {\n  const options = getOptions(optionalArg)\n  const delegated = delegatedEvents[type]\n  let matchFound = false\n  let index\n\n  if (!delegated) { return }\n\n  // count from last index of delegated to 0\n  for (index = delegated.selectors.length - 1; index >= 0; index--) {\n    // look for matching selector and context Node\n    if (delegated.selectors[index] === selector &&\n        delegated.contexts[index] === context) {\n      const listeners = delegated.listeners[index]\n\n      // each item of the listeners array is an array: [function, capture, passive]\n      for (let i = listeners.length - 1; i >= 0; i--) {\n        const [fn, capture, passive] = listeners[i]\n\n        // check if the listener functions and capture and passive flags match\n        if (fn === listener && capture === !!options.capture && passive === options.passive) {\n          // remove the listener from the array of listeners\n          listeners.splice(i, 1)\n\n          // if all listeners for this interactable have been removed\n          // remove the interactable from the delegated arrays\n          if (!listeners.length) {\n            delegated.selectors.splice(index, 1)\n            delegated.contexts.splice(index, 1)\n            delegated.listeners.splice(index, 1)\n\n            // remove delegate function from context\n            remove(context, type, delegateListener)\n            remove(context, type, delegateUseCapture, true)\n\n            // remove the arrays if they are empty\n            if (!delegated.selectors.length) {\n              delegatedEvents[type] = null\n            }\n          }\n\n          // only remove one listener\n          matchFound = true\n          break\n        }\n      }\n\n      if (matchFound) { break }\n    }\n  }\n}\n\n// bound to the interactable context when a DOM event\n// listener is added to a selector interactable\nfunction delegateListener (event: Event, optionalArg?: any) {\n  const options = getOptions(optionalArg)\n  const fakeEvent = new FakeEvent(event)\n  const delegated = delegatedEvents[event.type]\n  const [eventTarget] = (pointerUtils.getEventTargets(event))\n  let element: Node = eventTarget\n\n  // climb up document tree looking for selector matches\n  while (is.element(element)) {\n    for (let i = 0; i < delegated.selectors.length; i++) {\n      const selector = delegated.selectors[i]\n      const context = delegated.contexts[i]\n\n      if (domUtils.matchesSelector(element, selector) &&\n          domUtils.nodeContains(context, eventTarget) &&\n          domUtils.nodeContains(context, element)) {\n        const listeners = delegated.listeners[i]\n\n        fakeEvent.currentTarget = element\n\n        for (const [fn, capture, passive] of listeners) {\n          if (capture === !!options.capture && passive === options.passive) {\n            fn(fakeEvent)\n          }\n        }\n      }\n    }\n\n    element = domUtils.parentNode(element)\n  }\n}\n\nfunction delegateUseCapture (event: Event) {\n  return delegateListener.call(this, event, true)\n}\n\nfunction getOptions (param: object) {\n  return is.object(param) ? param : { capture: param }\n}\n\nexport class FakeEvent implements Partial<Event> {\n  currentTarget: EventTarget\n\n  constructor (public originalEvent: Event) {\n    // duplicate the event so that currentTarget can be changed\n    pExtend(this, originalEvent)\n  }\n\n  preventOriginalDefault () {\n    this.originalEvent.preventDefault()\n  }\n\n  stopPropagation () {\n    this.originalEvent.stopPropagation()\n  }\n\n  stopImmediatePropagation () {\n    this.originalEvent.stopImmediatePropagation()\n  }\n}\n\nconst events = {\n  add,\n  remove,\n\n  addDelegate,\n  removeDelegate,\n\n  delegateListener,\n  delegateUseCapture,\n  delegatedEvents,\n  documents,\n\n  supportsOptions: false,\n  supportsPassive: false,\n\n  _elements: elements,\n  _targets: targets,\n\n  init (window: Window) {\n    window.document.createElement('div').addEventListener('test', null, {\n      get capture () { return (events.supportsOptions = true) },\n      get passive () { return (events.supportsPassive = true) },\n    })\n  },\n}\n\nexport default events\n"
	]
}